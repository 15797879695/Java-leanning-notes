1. 说一说你了解的Java内存区域

   Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。

   
   Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：

   - 程序计数器
   - Java 虚拟机栈
   - 本地方法栈
   - Java 堆
   - 元数据区

   JDK8 之前，Hotspot 中方法区的实现是永久代（Perm）

   JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。

2. JDK8为什么要使用元空间取代永久代？

   原因如下：

   - 字符串存在永久代中，容易出现性能问题和内存溢出
   - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
   - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
   - 将 HotSpot 与 JRockit 合二为一

3. JVM中有哪几块内存空间？

   JVM 中的内存空间包括：

   - 程序计数器：可以看作是当前线程所执行的字节码文件（class）的行号指示器，它会记录执行痕迹，是每个线程私有的
   - 方法区：主要存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据，该区域是被线程共享的，很少发生垃圾回收
   - 栈：栈是运行时创建的，是线程私有的，生命周期与线程相同，存储声明的变量
   - 本地方法栈：为 native 方法服务，native 方法是一种由非 java 语言实现的 java 方法，与 java 环境外交互，如可以用本地方法与操作系统交互
   - 堆：堆是所有线程共享的一块内存，是在 java 虚拟机启动时创建的，几乎所有对象实例都在此创建，所以经常发生垃圾回收操作

4. 简单介绍下Java中垃圾回收机制

   **什么样的对象会被当做垃圾回收？**
   当一个对象的地址没有变量去引用时，该对象就会成为垃圾对象，垃圾回收器在空闲的时候会对其进行内存清理回收

    

   **如何检验对象是否被回收？**
   可以重写 Object 类中的 finalize 方法，这个方法在垃圾收集器执行的时候，被收集器自动调用执行的

    

   **怎样通知垃圾收集器回收对象？**
   可以调用 System 类的静态方法 gc()，通知垃圾收集器去清理垃圾，但不能保证收集动作立即执行，具体的执行时间取决于垃圾收集的算法

5. Java中类加载过程是什么样的？

   类加载的步骤为，加载 -> 验证 -> 准备 -> 解析 -> 初始化。

   1、加载：

   - 获取类的二进制字节流
   - 将字节流代表的静态存储结构转化为方法区运行时数据结构
   - 在堆中生成class字节码对象

   2、验证：连接过程的第一步，确保 class 文件的字节流中的信息符合当前 JVM 的要求，不会危害 JVM 的安全

   3、准备：为类的静态变量分配内存并将其初始化为默认值

   4、解析：JVM 将常量池内符号引用替换成直接引用的过程

   5、初始化：执行类构造器的初始化的过程

6.  对象创建过程是什么样的？

   对象在 JVM 中的创建过程如下：

   - JVM 会先去方法区找有没有所创建对象的类存在，有就可以创建对象了，没有则把该类加载到方法区
   - 在创建类的对象时，首先会先去堆内存中分配空间
   - 当空间分配完后，加载对象中所有的非静态成员变量到该空间下
   - 所有的非静态成员变量加载完成之后，对所有的非静态成员进行默认初始化
   - 所有的非静态成员默认初始化完成之后，调用相应的构造方法到栈中
   - 在栈中执行构造函数时，先执行隐式，再执行构造方法中书写的代码
   - 执行顺序：静态代码库，构造代码块，构造方法
   - 当整个构造方法全部执行完，此对象创建完成，并把堆内存中分配的空间地址赋给对象名

7. 方法区内存溢出怎么处理？

   在 Java 虚拟机中，方法区是可供各线程共享的运行时内存区域。

   在不同的 JDK 版本中，方法区中存储的数据是不一样的：

   - JDK 1.7 之前的版本，运行时常量池是方法区的一个部分，同时方法区里面存储了类的元数据信息、静态变量、即时编译器编译后的代码等。
   - JDK 1.7 开始，JVM 已经将运行时常量池从方法区中移了出来，在 JVM 开辟了一块区域存放常量池。

    

   永久代就是 HotSpot 版的 Java 虚拟机对虚拟机规范中方法区的一种实现方式，永久代和方法区的关系就像 Java 中类和接口的关系。

    

   HotSpot 版的 Java 虚拟机在 JDK 1.8 之后取消了永久代，改为元空间，类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。

    

   **在 jdk 1.7 及之前版本出现内存溢出的处理办法：**

   - 检查代码中是否出现死循环
   - 是否创建了过多或过大的对象
   - 是否出现死锁现象
   - 提高 jvm 堆内存大小的配置